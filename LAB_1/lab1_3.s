@============================================================================
@ *lab1_3.s*
@ Description: ARM Code to simulate behaviour of Fast Multiplication without 
@              MUL (e.g. MULF r1,r2,#54)
@============================================================================
@============================================================================
@
@ EDIT HISTORY FOR MODULE
@
@ $Header: $
@
@ when          who                    what, where, why
@ -----------   -------------------    -----------------------
@ 7 Sep 2019    Swapneel Pimparkar     Added and Tested Logic of shift & add.
@ 7 Sep 2019    Swapneel Pimparkar     (Bengaluru) First Draft
@============================================================================

@------------------------------------------------------------------------------
@ Logic: Actually, Karatsuba algorithm is the one used for fast multiplication.
@        As far as manual multiplication methods are concerned, we have many 
@        options such as grid method, japanese multiplication style, long 
@        multiplication, vedic mathematics formulae such as Nikhilam Navatah, 
@        Charamam Dashatah etc., lattice multiplication, binary multiplication,
@        (also called as peasant multiplication), shift and add, quarter square
@        multiplication, toom-cook multiplication, fourier transform method, 
@        kronecker substitution and many others.
@        
@ Note:  Assumed is Integer Multiplication only. 
@        Written first was C program without '*' operator so that MUL variant
@        instructions are not generated by the compiler.
@        This code is essentially generated using arm compiler with -O1 flag
@        tuned for 32 bit ARMv4. This is in essense using shift & add method.
@        This is verified for positive multiplication only.
@------------------------------------------------------------------------------

@ Text Section Begins
.text

@ Global labels declared. For description of logic_x please refer above comments.
@ related to associated logic.

    .global _START
    .global _END
    .global _LOOP
    .global _COMMON

_START:
    MOV     R3, #54  @Input value 1 (taken from exercise)
    MOV     R2, #3   @Input value 2 (assuming 3)
    
    MOV     R1, #0  @Output will be stored in R1      
    MOV     R4, R3 

@ Following two MOV instructions are not necessary but we are using R5 and R6
@ so that input values in R2 and R3 can be preserved. Just for our visualization.
@ And hence all the operations are done on R5 and R6 below.

    MOV     R5, R3  
    MOV     R6, R2  

_LOOP:
    TST     R6, #1        
    ADDNE   R1, R1, R4        
    MOV     R4, R4, ASL #1        
    ADD     R6, R6, R6, LSR #31        
    MOV     R6, R6, ASR #1        
    SUBS    R5, R5, #1        
    BNE     _LOOP
    
_END:
@ End the program
.end
